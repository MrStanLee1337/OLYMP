template <typename Value>
class ITreap{
    struct node {
        int priority, size;
        Value value;
        node(Value value): value(value), priority(rand()), size(1){}
        node *left = nullptr, *right = nullptr, *parent = nullptr;
        void update () { size = 1 + (left ? left->size : 0) + (right ? right->size : 0); }
    } *root = nullptr;
    
    static void update(node *a){
        a->update();
        setParent(a->left, a);
        setParent(a->right, a);
    }
    static void setParent(node* me, node* mom){
        if(me) me->parent = mom;
    }
    
    static int getSize(node *a){
        return a ? a->size : 0;
    }
    
    node *merge(node *a, node *b){
        if(!a) return b;
        if(!b) return a;
        if(a->priority > b->priority){
            a->right = merge(a->right, b);
            update(a);
            return a;
        } else {
            b->left = merge(a, b->left);
            update(b);
            return b;
        }
    }
    pair<node*, node*> split(node* p, int count){
        if(!p) return {nullptr, nullptr};
        pair<node*, node*> res;
            int ls = getSize(p->left);
            if (ls >= count) {
                auto tmp = split(p->left, count);
                p->left = tmp.second;
                update(p);
                res.first = tmp.first;
                res.second = p;
            } else {
                auto tmp = split(p->right, count - ls - 1);
                p->right = tmp.first;
                update(p);
                res.first = p;
                res.second = tmp.second;
            }
        setParent(res.first, nullptr);
        setParent(res.second, nullptr);
        return res;
    }
    node* find(int index){
        if (index < 0 || index >= getSize(root)) {
            cout << "\nВыход за ограничения\n";
            return 0;
        }
        node* p = root;
        while (true) {
            int left_size = getSize(p->left); 
            if (index == left_size) {
                return p;
            } else if (index < left_size) {
                p = p->left;
            } else {
                index -= (left_size + 1); 
                p = p->right;
            }
        }
    }
    
    void foreach(std::function<void (Value&)> f, node *p) {
        if (p == nullptr) return;
        foreach(f, p->left);
        f(p->value);
        foreach(f, p->right);
    }

public:
    int size(){ return root ? root->size : 0;}
    void insert(int index, int value){
        auto [less, greater] = split(root, index);
        root = merge(merge(less, new node(value)), greater);
    }
    void push_back(int value){
        root = merge(root, new node(value));
    }
    void push_front(int value){
        root = merge(new node(value), root);
    }
    void erase(int index){
        node *less, *greater, *equal;
        make_pair(less, greater)  = split(root, index);
        make_pair(equal, greater) = split(greater, 1);
        root = merge(less, greater);
        
    }
    Value operator[](int index) const {
        return find(index)->value;
    }
    
    Value& operator[](int index) {
        int &result = find(index)->value;
        return result;
    }
    void foreach(std::function<void (Value&)> f) {
        foreach(f, root);
    }
    
};
