bool nextPermutation(string &s, int n)
{
    // Найдите наибольший индекс `i`, такой, что `s[i-1]` меньше, чем `s[i]`
    int i = n-1;
    
    while (s[i-1] >= s[i]){
        // если `i` это первый индекс строки, мы уже на последнем
        // возможная перестановка (строка сортируется в обратном порядке)
        if (--i == 0) {
            return false;
        }
    }
    
    // Если мы дойдем до этого места, подстрока `s[i…n-1]` будет отсортирована в обратном порядке.
    // Найдите наибольший индекс `j` справа от индекса `i`, такой, что `s[j] > s[i-1]`.
    int j = n-1;
    while (j > i && s[j] <= s[i-1]) {
        j--;
    }
    // поменять местами символ с индексом `i-1` на индекс `j`
    swap(s[i-1], s[j]);
 
    // Перевернуть подстроку `s[i…n-1]`и вернуть true
    reverse (s.begin() + i, s.end());
 
    return true;
}

int main(){
    //int n,m,k;
    //cin >> n >> m >> k;
    string str;
    //for(int i = 0; i < n; i++) str += 'D';
    //for(int j = 0; j < m; j++) str += 'R';
    str = "00011";
    
    do {
        // печатаем текущую перестановку
        cout << str << " ";
        // найти следующую перестановку в лексикографическом порядке
    } while(nextPermutation(str, str.length()));
    return 0;
}
